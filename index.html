<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Figma-in-a-tag: X-Ray Edition</title>
    <style id="editor-ui-styles">
        /* --- HANDLES & OVERLAY (Previous) --- */
        .proto-handle {
            position: absolute; width: 12px; height: 12px; z-index: 2147483647; 
            pointer-events: auto; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            border-radius: 2px; transition: transform 0.1s;
        }
        .proto-handle:hover { transform: scale(1.4); z-index: 2147483648; }
        .handle-resize { background: white; border: 1px solid #3b82f6; }
        .handle-resize:hover { background: #3b82f6; }
        .handle-pad { background: #4ade80; border: 1px solid #16a34a; border-radius: 50%; }
        .handle-pad:hover { background: #16a34a; }
        .handle-marg { background: #fb923c; border: 1px solid #ea580c; }
        .handle-marg:hover { background: #ea580c; }
        .proto-overlay {
            position: fixed; pointer-events: none; z-index: 2147483646;
            border: 2px solid #3b82f6; transition: none;
        }
        
        /* --- MENU INPUTS --- */
        .proto-input {
            background: #f9fafb; border: 1px solid #d1d5db; border-radius: 3px;
            padding: 2px 4px; font-size: 10px; width: 100%; font-family: monospace;
            text-align: center;
        }
        .proto-input:focus { outline: none; border-color: #3b82f6; background: white; }

        /* --- BREADCRUMB BAR (New) --- */
        .proto-breadcrumbs {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(4px);
            color: white; padding: 6px 16px; border-radius: 20px;
            display: flex; align-items: center; gap: 8px;
            font-family: monospace; font-size: 12px;
            z-index: 2147483647; box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .proto-crumb {
            cursor: pointer; opacity: 0.7; transition: all 0.2s;
            border: none; background: none; color: inherit; padding: 0; font-family: inherit;
        }
        .proto-crumb:hover { opacity: 1; text-decoration: underline; }
        .proto-crumb.active { opacity: 1; font-weight: bold; color: #60a5fa; }
        .proto-sep { opacity: 0.4; }
    </style>
</head>
<body class="p-20 bg-gray-50">
    <div class="mb-10">
        <h1 class="text-4xl font-bold text-gray-800">X-Ray Mode</h1>
        <p class="text-lg text-gray-600">Select the inner text below, then use the black bar at the bottom to select the parent box.</p>
    </div>

    <div class="w-[300px] h-[300px] bg-white border border-gray-300 shadow-md p-10">
        <div class="w-full h-full bg-blue-50 border border-blue-200 p-8">
            <div class="w-full h-full bg-blue-100 flex items-center justify-center text-blue-500 font-bold border border-blue-300">
                Inner Content
            </div>
        </div>
    </div>

    <script>
        (function() {
            const TAILWIND_CDN = 'https://cdn.tailwindcss.com';
            
            // --- CONSTANTS ---
            const OPTIONS = {
                textSize: ['text-xs', 'text-sm', 'text-base', 'text-lg', 'text-xl', 'text-2xl', 'text-3xl', 'text-4xl'],
                fontFamily: ['font-sans', 'font-serif', 'font-mono'],
                fontWeight: ['font-thin', 'font-normal', 'font-bold', 'font-black'],
                rounded: ['rounded-none', 'rounded-sm', 'rounded', 'rounded-md', 'rounded-lg', 'rounded-full'],
                borderWidth: ['border-0', 'border', 'border-2', 'border-4', 'border-8'],
                textAlign: ['text-left', 'text-center', 'text-right', 'text-justify'],
                flexDir: ['flex-row', 'flex-col'],
                justify: ['justify-start', 'justify-end', 'justify-center', 'justify-between'],
                items: ['items-start', 'items-end', 'items-center']
            };

            let selectedElement = null;
            let mouseX = 0, mouseY = 0;

            // --- BREADCRUMB MANAGER (New) ---
            const BreadcrumbManager = {
                bar: null,
                update: () => {
                    // Create bar if missing
                    if (!BreadcrumbManager.bar) {
                        BreadcrumbManager.bar = document.createElement('div');
                        BreadcrumbManager.bar.className = 'proto-breadcrumbs';
                        document.body.appendChild(BreadcrumbManager.bar);
                    }

                    if (!selectedElement) {
                        BreadcrumbManager.bar.style.display = 'none';
                        return;
                    }

                    BreadcrumbManager.bar.style.display = 'flex';
                    BreadcrumbManager.bar.innerHTML = ''; 

                    // Build Hierarchy Chain
                    const chain = [];
                    let curr = selectedElement;
                    while(curr && curr !== document.documentElement) { // Stop at HTML tag
                        chain.unshift(curr);
                        if (curr === document.body) break; // Stop after adding Body
                        curr = curr.parentElement;
                    }

                    // Render Chain
                    chain.forEach((el, index) => {
                        const btn = document.createElement('button');
                        btn.className = 'proto-crumb';
                        
                        // Smart Label: "div.w-full"
                        let label = el.tagName.toLowerCase();
                        if (el.id && !el.id.startsWith('proto')) label += `#${el.id}`;
                        else if (el.classList.length > 0) {
                            // Pick the first class that isn't a utility spam if possible, or just the first one
                            const cls = Array.from(el.classList).find(c => !c.startsWith('w-') && !c.startsWith('h-')) || el.classList[0];
                            if (cls) label += `.${cls}`;
                        }
                        
                        // Truncate if too long
                        if(label.length > 15) label = label.substring(0, 12) + '...';

                        btn.innerText = label;
                        if (el === selectedElement) btn.classList.add('active');

                        btn.onclick = (e) => {
                            e.stopPropagation();
                            // Standard Selection Trigger
                            const menu = document.getElementById('proto-menu'); if (menu) menu.remove();
                            selectedElement = el;
                            OverlayManager.update();
                            BreadcrumbManager.update(); // Refresh breadcrumb to show new active
                        };
                        
                        BreadcrumbManager.bar.appendChild(btn);
                        
                        // Separator
                        if (index < chain.length - 1) {
                            const sep = document.createElement('span');
                            sep.className = 'proto-sep';
                            sep.innerText = '>';
                            BreadcrumbManager.bar.appendChild(sep);
                        }
                    });
                }
            };

            // --- HISTORY MANAGER ---
            const HistoryManager = {
                undoStack: [], redoStack: [], maxDepth: 50,
                getCleanState: () => {
                    const clone = document.body.cloneNode(true);
                    // UPDATE: Remove breadcrumbs from snapshot too
                    const ui = clone.querySelectorAll('#proto-menu, #proto-save-btn, .proto-overlay, .proto-handle, .proto-breadcrumbs');
                    ui.forEach(el => el.remove());
                    return clone.innerHTML;
                },
                pushState: () => {
                    const state = HistoryManager.getCleanState();
                    HistoryManager.undoStack.push(state);
                    if (HistoryManager.undoStack.length > HistoryManager.maxDepth) HistoryManager.undoStack.shift();
                    HistoryManager.redoStack = []; 
                },
                undo: () => {
                    if (HistoryManager.undoStack.length === 0) return;
                    HistoryManager.redoStack.push(HistoryManager.getCleanState());
                    HistoryManager.restore(HistoryManager.undoStack.pop());
                },
                redo: () => {
                    if (HistoryManager.redoStack.length === 0) return;
                    HistoryManager.undoStack.push(HistoryManager.getCleanState());
                    HistoryManager.restore(HistoryManager.redoStack.pop());
                },
                restore: (htmlContent) => {
                    if (selectedElement) { selectedElement = null; OverlayManager.update(); BreadcrumbManager.update(); }
                    const menu = document.getElementById('proto-menu'); if (menu) menu.remove();
                    const btn = document.getElementById('proto-save-btn'); if (btn) btn.remove();
                    // Remove old breadcrumbs if any
                    const crumbs = document.querySelector('.proto-breadcrumbs'); if(crumbs) crumbs.remove();

                    document.body.innerHTML = htmlContent;
                    scanAndHydrate();
                    createSaveButton();
                }
            };

            // --- TAILWIND MANAGER ---
            const TwManager = {
                patterns: {
                    width: /^w-/, height: /^h-/, minWidth: /^min-w-/, minHeight: /^min-h-/, maxWidth: /^max-w-/, maxHeight: /^max-h-/, 
                    pt: /^pt-/, pr: /^pr-/, pb: /^pb-/, pl: /^pl-/, mt: /^mt-/, mr: /^mr-/, mb: /^mb-/, ml: /^ml-/,
                    padding: /^p-/, margin: /^m-/, bgColor: /^bg-/, textColor: /^text-(?!xs|sm|base|lg|xl|\d+xl|left|center|right|justify)/, 
                    textSize: /^text-(xs|sm|base|lg|xl|\d+xl)/, fontFamily: /^font-(sans|serif|mono)/,
                    fontWeight: /^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)/,
                    rounded: /^rounded-/, borderWidth: /^border(-[0248])?$|^border$/,
                    flexDir: /^flex-(row|col)/, justify: /^justify-/, items: /^items-/, textAlign: /^text-(left|center|right|justify)/
                },
                update: (el, category, newValue) => {
                    const pattern = TwManager.patterns[category];
                    const toRemove = [];
                    el.classList.forEach(cls => { if (pattern.test(cls)) toRemove.push(cls); });
                    toRemove.forEach(c => el.classList.remove(c));
                    if (newValue && newValue.trim() !== '') el.classList.add(newValue.trim());
                },
                getValue: (el, category) => {
                    const pattern = TwManager.patterns[category];
                    let match = '';
                    el.classList.forEach(cls => { if (pattern.test(cls)) match = cls; });
                    if (category === 'borderWidth' && match === '' && el.classList.contains('border')) return 'border';
                    return match;
                }
            };

            // --- OVERLAY MANAGER ---
            const OverlayManager = {
                overlay: null,
                update: () => {
                    if (!selectedElement) {
                        if (OverlayManager.overlay) OverlayManager.overlay.remove();
                        OverlayManager.overlay = null;
                        return;
                    }
                    if (!OverlayManager.overlay) {
                        OverlayManager.overlay = document.createElement('div');
                        OverlayManager.overlay.className = 'proto-overlay';
                        const handles = [
                            { type: 'resize-r',  cls: 'handle-resize', cursor: 'ew-resize',   pos: 'top: 50%; right: -6px; transform: translateY(-50%);' },
                            { type: 'resize-b',  cls: 'handle-resize', cursor: 'ns-resize',   pos: 'bottom: -6px; left: 50%; transform: translateX(-50%);' },
                            { type: 'resize-br', cls: 'handle-resize', cursor: 'nwse-resize', pos: 'bottom: -6px; right: -6px;' },
                            { type: 'pt', cls: 'handle-pad', cursor: 'ns-resize', title: 'Padding Top', side: 'pt' },
                            { type: 'pr', cls: 'handle-pad', cursor: 'ew-resize', title: 'Padding Right', side: 'pr' },
                            { type: 'pb', cls: 'handle-pad', cursor: 'ns-resize', title: 'Padding Bottom', side: 'pb' },
                            { type: 'pl', cls: 'handle-pad', cursor: 'ew-resize', title: 'Padding Left', side: 'pl' },
                            { type: 'mt', cls: 'handle-marg', cursor: 'ns-resize', title: 'Margin Top', side: 'mt' },
                            { type: 'mr', cls: 'handle-marg', cursor: 'ew-resize', title: 'Margin Right', side: 'mr' },
                            { type: 'mb', cls: 'handle-marg', cursor: 'ns-resize', title: 'Margin Bottom', side: 'mb' },
                            { type: 'ml', cls: 'handle-marg', cursor: 'ew-resize', title: 'Margin Left', side: 'ml' }
                        ];
                        handles.forEach(h => {
                            const handle = document.createElement('div');
                            handle.className = `proto-handle ${h.cls}`;
                            handle.style.cursor = h.cursor;
                            if(h.title) handle.title = h.title;
                            handle.dataset.type = h.type;
                            handle.addEventListener('mousedown', (e) => {
                                e.stopPropagation(); e.preventDefault();
                                OverlayManager.startDrag(e, h.type, handle);
                            });
                            OverlayManager.overlay.appendChild(handle);
                        });
                        document.body.appendChild(OverlayManager.overlay);
                    }
                    const rect = selectedElement.getBoundingClientRect();
                    Object.assign(OverlayManager.overlay.style, { top: `${rect.top}px`, left: `${rect.left}px`, width: `${rect.width}px`, height: `${rect.height}px` });
                    const style = window.getComputedStyle(selectedElement);
                    const p = { t: parseFloat(style.paddingTop)||0, r: parseFloat(style.paddingRight)||0, b: parseFloat(style.paddingBottom)||0, l: parseFloat(style.paddingLeft)||0 };
                    const m = { t: parseFloat(style.marginTop)||0, r: parseFloat(style.marginRight)||0, b: parseFloat(style.marginBottom)||0, l: parseFloat(style.marginLeft)||0 };
                    const setPos = (type, css) => { const h = OverlayManager.overlay.querySelector(`[data-type="${type}"]`); if(h) Object.assign(h.style, css); };
                    
                    setPos('resize-r',  { top: '50%', right: '-6px', transform: 'translateY(-50%)' });
                    setPos('resize-b',  { bottom: '-6px', left: '50%', transform: 'translateX(-50%)' });
                    setPos('resize-br', { bottom: '-6px', right: '-6px' });
                    setPos('pt', { top: `${Math.max(10, p.t)}px`, left: '50%', transform: 'translateX(-50%)' });
                    setPos('pb', { bottom: `${Math.max(10, p.b)}px`, left: '50%', transform: 'translateX(-50%)' });
                    setPos('pl', { left: `${Math.max(10, p.l)}px`, top: '50%', transform: 'translateY(-50%)' });
                    setPos('pr', { right: `${Math.max(10, p.r)}px`, top: '50%', transform: 'translateY(-50%)' });
                    setPos('mt', { top: `-${Math.max(15, m.t)}px`, left: '50%', transform: 'translateX(-50%)' });
                    setPos('mb', { bottom: `-${Math.max(15, m.b)}px`, left: '50%', transform: 'translateX(-50%)' });
                    setPos('ml', { left: `-${Math.max(15, m.l)}px`, top: '50%', transform: 'translateY(-50%)' });
                    setPos('mr', { right: `-${Math.max(15, m.r)}px`, top: '50%', transform: 'translateY(-50%)' });
                },

                startDrag: (e, type, handleElement) => {
                    HistoryManager.pushState();
                    const startX = e.clientX; const startY = e.clientY;
                    const rect = selectedElement.getBoundingClientRect();
                    const style = window.getComputedStyle(selectedElement);
                    const elStyle = selectedElement.style; const overlayStyle = OverlayManager.overlay.style;
                    const startOverlayTop = rect.top; const startOverlayLeft = rect.left;
                    const initial = {
                        w: rect.width, h: rect.height,
                        pt: parseFloat(style.paddingTop)||0, pr: parseFloat(style.paddingRight)||0, pb: parseFloat(style.paddingBottom)||0, pl: parseFloat(style.paddingLeft)||0,
                        mt: parseFloat(style.marginTop)||0, mr: parseFloat(style.marginRight)||0, mb: parseFloat(style.marginBottom)||0, ml: parseFloat(style.marginLeft)||0
                    };

                    const onMove = (ev) => {
                        const dx = ev.clientX - startX; const dy = ev.clientY - startY;
                        if (type.startsWith('resize')) {
                            let newW = initial.w, newH = initial.h;
                            if (type.includes('r')) newW = Math.max(10, initial.w + dx);
                            if (type.includes('b')) newH = Math.max(10, initial.h + dy);
                            elStyle.width = `${newW}px`; elStyle.height = `${newH}px`; overlayStyle.width = `${newW}px`; overlayStyle.height = `${newH}px`;
                        }
                        if (type === 'pt') { const val=Math.max(0,initial.pt+dy); elStyle.paddingTop=`${val}px`; handleElement.style.top=`${Math.max(10,val)}px`; }
                        if (type === 'pb') { const val=Math.max(0,initial.pb-dy); elStyle.paddingBottom=`${val}px`; handleElement.style.bottom=`${Math.max(10,val)}px`; }
                        if (type === 'pl') { const val=Math.max(0,initial.pl+dx); elStyle.paddingLeft=`${val}px`; handleElement.style.left=`${Math.max(10,val)}px`; }
                        if (type === 'pr') { const val=Math.max(0,initial.pr-dx); elStyle.paddingRight=`${val}px`; handleElement.style.right=`${Math.max(10,val)}px`; }
                        if (type === 'mt') { const val=initial.mt-dy; elStyle.marginTop=`${val}px`; overlayStyle.top=`${startOverlayTop-dy}px`; handleElement.style.top=`-${Math.max(15,val)}px`; }
                        if (type === 'mb') { const val=initial.mb+dy; elStyle.marginBottom=`${val}px`; handleElement.style.bottom=`-${Math.max(15,val)}px`; }
                        if (type === 'ml') { const val=initial.ml-dx; elStyle.marginLeft=`${val}px`; overlayStyle.left=`${startOverlayLeft-dx}px`; handleElement.style.left=`-${Math.max(15,val)}px`; }
                        if (type === 'mr') { const val=initial.mr+dx; elStyle.marginRight=`${val}px`; handleElement.style.right=`-${Math.max(15,val)}px`; }
                    };

                    const onUp = () => {
                        window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp);
                        const s = selectedElement.style;
                        const mappings = [
                            { prop: 'width', tw: 'width', pfx: 'w' }, { prop: 'height', tw: 'height', pfx: 'h' },
                            { prop: 'paddingTop', tw: 'pt', pfx: 'pt' }, { prop: 'paddingRight', tw: 'pr', pfx: 'pr' }, { prop: 'paddingBottom', tw: 'pb', pfx: 'pb' }, { prop: 'paddingLeft', tw: 'pl', pfx: 'pl' },
                            { prop: 'marginTop', tw: 'mt', pfx: 'mt' }, { prop: 'marginRight', tw: 'mr', pfx: 'mr' }, { prop: 'marginBottom', tw: 'mb', pfx: 'mb' }, { prop: 'marginLeft', tw: 'ml', pfx: 'ml' }
                        ];
                        mappings.forEach(m => { const val = s[m.prop]; if (val) { TwManager.update(selectedElement, m.tw, `${m.pfx}-[${val}]`); s[m.prop] = ''; } });
                        document.body.classList.add('jit-refresh');
                        setTimeout(() => { document.body.classList.remove('jit-refresh'); OverlayManager.update(); }, 50);
                    };
                    window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
                }
            };

            // --- INIT ---
            function makeEditable(el) {
                if (el._figma_bound) return; el._figma_bound = true; el.dataset.editable = "true";
                if (el.tagName === 'DIV' && el.innerHTML.trim() === '') el.classList.add('min-w-[50px]', 'min-h-[50px]', 'border', 'border-dashed', 'border-gray-300');
                el.addEventListener('click', (ev) => {
                    ev.stopPropagation(); const menu = document.getElementById('proto-menu'); if (menu) menu.remove();
                    selectedElement = el; 
                    OverlayManager.update();
                    BreadcrumbManager.update(); // UPDATE BREADCRUMBS
                });
            }
            window.addEventListener('scroll', () => { if(selectedElement) OverlayManager.update(); }, true);
            window.addEventListener('resize', () => { if(selectedElement) OverlayManager.update(); });
            function initializeEnvironment() {
                let hasTailwind = false;
                document.querySelectorAll('script').forEach(s => { if (s.src && s.src.includes('tailwindcss')) hasTailwind = true; });
                if (!hasTailwind) { nukeStyles(); injectTailwind(); }
                scanAndHydrate();
            }
            function nukeStyles() {
                document.querySelectorAll('link[rel="stylesheet"], style:not(#editor-ui-styles)').forEach(el => el.disabled = true);
                const all = document.body.getElementsByTagName("*"); for (let el of all) el.removeAttribute("style");
                document.body.removeAttribute("style");
            }
            function injectTailwind() {
                const script = document.createElement('script'); script.src = TAILWIND_CDN;
                script.onload = () => { document.body.classList.add('jit-wake-up'); setTimeout(() => document.body.classList.remove('jit-wake-up'), 0); };
                document.head.appendChild(script);
            }
            function scanAndHydrate() {
                const all = document.body.getElementsByTagName('*');
                for (let el of all) {
                    if (el.tagName === 'SCRIPT' || (el.id && el.id.startsWith('proto-')) || el.classList.contains('proto-handle') || el.classList.contains('proto-overlay') || el.classList.contains('proto-breadcrumbs')) continue;
                    makeEditable(el);
                }
            }
            initializeEnvironment();
            document.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });

            // --- UI HELPERS ---
            function createMenu(x, y, content) {
                const existing = document.getElementById('proto-menu'); if (existing) existing.remove();
                const menu = document.createElement('div'); menu.id = 'proto-menu';
                menu.className = `fixed z-[2147483647] bg-white border border-gray-200 shadow-2xl rounded-lg flex flex-col min-w-[260px] p-3 font-mono text-xs max-h-[80vh] overflow-y-auto`;
                menu.style.top = `${y}px`; menu.style.left = `${x}px`;
                content.forEach(item => menu.appendChild(item)); document.body.appendChild(menu);
            }
            function createSaveButton() {
                const btn = document.createElement('button'); btn.innerText = "ðŸ’¾ Save Project"; btn.id = "proto-save-btn";
                btn.className = "fixed bottom-5 right-5 z-[2147483647] bg-blue-600 text-white font-bold py-2 px-4 rounded shadow-lg hover:bg-blue-700";
                btn.onclick = () => {
                    const menu = document.getElementById('proto-menu'); if (menu) menu.remove(); btn.remove();
                    selectedElement = null; OverlayManager.update(); BreadcrumbManager.update();
                    const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([document.documentElement.outerHTML], {type: "text/html"}));
                    a.download = "index.html"; document.body.appendChild(a); a.click(); document.body.removeChild(a); document.body.appendChild(btn);
                };
                document.body.appendChild(btn);
            }
            createSaveButton();

            // --- CONTEXT & CREATE MENU (Standard) ---
            document.addEventListener('contextmenu', (e) => {
                if (!selectedElement) return; e.preventDefault();
                const createControl = (label, category, type = 'text', options = []) => {
                    const row = document.createElement('div'); row.className = "flex justify-between items-center mb-2";
                    const lbl = document.createElement('span'); lbl.className = "text-gray-500 font-bold mr-3 w-20 truncate"; lbl.innerText = label;
                    let input;
                    const changeHandler = (val) => { HistoryManager.pushState(); TwManager.update(selectedElement, category, val); OverlayManager.update(); };
                    if (type === 'select') {
                        input = document.createElement('select'); input.className = "proto-input";
                        const def = document.createElement('option'); def.value = ""; def.innerText = "-"; input.appendChild(def);
                        options.forEach(opt => { const o = document.createElement('option'); o.value = opt; o.innerText = opt; input.appendChild(o); });
                        input.value = TwManager.getValue(selectedElement, category); input.onchange = () => changeHandler(input.value);
                    } else {
                        input = document.createElement('input'); input.type = 'text'; input.className = "proto-input";
                        input.value = TwManager.getValue(selectedElement, category); input.onchange = () => changeHandler(input.value);
                    }
                    row.appendChild(lbl); row.appendChild(input); return row;
                };
                const createQuad = (label, categories) => {
                    const row = document.createElement('div'); row.className = "flex flex-col mb-2";
                    const header = document.createElement('div'); header.className = "flex justify-between mb-1";
                    const lbl = document.createElement('span'); lbl.className = "text-gray-500 font-bold"; lbl.innerText = label; header.appendChild(lbl); row.appendChild(header);
                    const grid = document.createElement('div'); grid.className = "grid grid-cols-2 gap-1"; 
                    const placeholders = ['Top', 'Right', 'Bottom', 'Left'];
                    categories.forEach((cat, i) => {
                        const input = document.createElement('input'); input.type = 'text'; input.className = "proto-input text-center";
                        input.placeholder = placeholders[i]; input.value = TwManager.getValue(selectedElement, cat);
                        input.onchange = () => { HistoryManager.pushState(); TwManager.update(selectedElement, cat, input.value); OverlayManager.update(); };
                        grid.appendChild(input);
                    });
                    row.appendChild(grid); return row;
                };
                const items = []; const tag = selectedElement.tagName;
                const title = document.createElement('div'); title.innerText = `<${tag.toLowerCase()}> Settings`; title.className = "mb-3 pb-2 border-b border-gray-100 font-bold text-gray-800 uppercase tracking-wider"; items.push(title);
                if (['DIV', 'IMG', 'H1', 'P', 'SPAN', 'BUTTON'].includes(tag)) {
                    items.push(createControl('Width', 'width')); items.push(createControl('Height', 'height'));
                    items.push(createControl('Pad (All)', 'padding')); items.push(createQuad('Padding (T R B L)', ['pt', 'pr', 'pb', 'pl']));
                    items.push(createControl('Marg (All)', 'margin')); items.push(createQuad('Margin (T R B L)', ['mt', 'mr', 'mb', 'ml']));
                }
                if (tag === 'DIV') {
                    items.push(createControl('Bg Color', 'bgColor')); items.push(createControl('Radius', 'rounded', 'select', OPTIONS.rounded)); items.push(createControl('Border', 'borderWidth', 'select', OPTIONS.borderWidth)); items.push(createControl('Direction', 'flexDir', 'select', OPTIONS.flexDir)); items.push(createControl('Justify', 'justify', 'select', OPTIONS.justify)); items.push(createControl('Align', 'items', 'select', OPTIONS.items));
                }
                if (['H1', 'P', 'SPAN', 'BUTTON', 'A'].includes(tag)) {
                    items.push(createControl('Font', 'fontFamily', 'select', OPTIONS.fontFamily)); items.push(createControl('Weight', 'fontWeight', 'select', OPTIONS.fontWeight)); items.push(createControl('Size', 'textSize', 'select', OPTIONS.textSize)); items.push(createControl('Align', 'textAlign', 'select', OPTIONS.textAlign)); items.push(createControl('Color', 'textColor'));
                    const txtInp = document.createElement('textarea'); txtInp.className = "bg-gray-50 border border-gray-300 rounded px-2 py-1 w-full text-xs h-16 mt-2 font-sans"; txtInp.value = selectedElement.innerText;
                    txtInp.onchange = () => { HistoryManager.pushState(); selectedElement.innerText = txtInp.value; }; items.push(txtInp);
                }
                const delBtn = document.createElement('button'); delBtn.innerText = "Delete Element"; delBtn.className = "mt-4 w-full bg-red-50 text-red-600 border border-red-200 rounded py-2 hover:bg-red-100";
                delBtn.onclick = () => { if(confirm("Delete?")) { HistoryManager.pushState(); selectedElement.remove(); selectedElement = null; OverlayManager.update(); BreadcrumbManager.update(); document.getElementById('proto-menu').remove(); }};
                items.push(delBtn);
                createMenu(e.clientX, e.clientY, items);
            });

            // --- SHORTCUTS ---
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) HistoryManager.redo(); else HistoryManager.undo(); }
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); HistoryManager.redo(); }
                if (e.shiftKey && e.key.toLowerCase() === 'a') {
                    const items = ['div', 'text', 'img'].map(opt => {
                        const btn = document.createElement('button'); btn.innerText = opt.toUpperCase();
                        btn.className = "w-full text-left px-3 py-2 hover:bg-blue-50 hover:text-blue-600 rounded text-gray-700 font-bold transition-colors";
                        btn.onclick = () => { 
                            HistoryManager.pushState();
                            let newEl; if (opt === 'div') { newEl = document.createElement('div'); newEl.className = "min-w-[150px] min-h-[150px] bg-gray-100 border-2 border-dashed border-gray-300 p-4 m-2 flex flex-col"; } else if (opt === 'text') { newEl = document.createElement('h1'); newEl.innerText = "New Heading"; newEl.className = "text-4xl font-bold text-gray-800 m-2"; } else if (opt === 'img') { newEl = document.createElement('img'); newEl.src = "https://via.placeholder.com/150"; newEl.className = "w-[150px] h-auto m-2"; } 
                            makeEditable(newEl); (selectedElement || document.body).appendChild(newEl); document.getElementById('proto-menu').remove(); selectedElement = newEl; OverlayManager.update(); BreadcrumbManager.update();
                        };
                        return btn;
                    });
                    createMenu(mouseX, mouseY, items);
                }
                if (e.key === 'Escape') { const menu = document.getElementById('proto-menu'); if(menu) menu.remove(); selectedElement = null; OverlayManager.update(); BreadcrumbManager.update(); }
                if (selectedElement && e.shiftKey) { 
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        HistoryManager.pushState();
                        const p = selectedElement.parentNode;
                        if (e.key === 'ArrowLeft') { const prev = selectedElement.previousElementSibling; if(prev) p.insertBefore(selectedElement, prev); } 
                        else if (e.key === 'ArrowRight') { const next = selectedElement.nextElementSibling; if(next) p.insertBefore(selectedElement, next.nextElementSibling); } 
                        OverlayManager.update(); 
                    }
                }
            });
        })();
    </script>
</body>
</html>